# 文档更新说明 - 2026-02-28 (第2次)

## 更新内容

补充了电源序列执行时机和 probe 延迟机制的详细说明。

## 主要修改

### 1. 澄清 probe 和上电的区别

**关键概念**：
- **probe 阶段**：只获取资源（GPIO、时钟），注册到链表，**不操作硬件**
- **rescan 阶段**：真正执行上电操作（使能时钟、拉高 GPIO）

### 2. 添加章节：3.5 Probe延迟机制 (EPROBE_DEFER)

回答了关键问题：
- ❓ `mmc_rescan` 执行时，`mmc_pwrseq_simple_probe` 有可能还没执行吗？
- ✅ **不可能**。内核通过 `-EPROBE_DEFER` 机制保证依赖顺序。

#### 工作原理

```
如果 pwrseq 未注册:
  dw_mci_probe()
    └─ mmc_pwrseq_alloc() 返回 -EPROBE_DEFER
        └─ probe 失败，内核稍后重试

pwrseq 注册后:
  dw_mci_probe() (重试)
    └─ mmc_pwrseq_alloc() 成功
        └─ mmc_start_host()
            └─ mmc_rescan() 执行上电
```

### 3. 更新流程图

#### 修改前
```
│ 2. 电源序列Pinctrl应用                      │
│ 3. 执行电源序列                              │
```

#### 修改后
```
│ 2. 电源序列驱动probe                        │
│    ⚠️ 注意: 只准备资源，不执行上电            │
│ 3. SDIO控制器驱动probe                      │
│    └─ mmc_pwrseq_alloc() 查找并绑定pwrseq   │
│ 4. 执行电源序列 (在mmc_rescan中)            │
│    ⚠️ 这里才真正上电                          │
```

### 4. 详细代码注释

#### mmc_pwrseq_simple_probe()
```c
mmc_pwrseq_simple_probe()
  ├─ devm_gpiod_get() - 只获取，不操作 ← 新增说明
  ├─ devm_clk_get() - 只获取，不使能 ← 新增说明
  └─ mmc_pwrseq_register() - 注册到链表
```

#### dw_mci_probe()
```c
dw_mci_probe()
  ├─ mmc_pwrseq_alloc()
  │    ├─ 如果找到: 绑定到 host->pwrseq
  │    └─ 如果未找到: 返回 -EPROBE_DEFER ← 新增说明
  │         └─ 内核稍后重试 probe
  └─ mmc_start_host()
       └─ 调度 mmc_rescan() 工作队列
```

#### mmc_rescan()
```c
mmc_rescan()
  └─ mmc_pwrseq_pre_power_on()
       ├─ clk_prepare_enable() ← 首次使能 (新增标注)
       └─ gpiod_set_value(1) ← 首次上电 (新增标注)
```

### 5. 添加关键依赖说明

在多处添加了警告标注：

```
⚠️ 关键依赖: 此步骤要求 pwrseq 必须已注册
如果 pwrseq 未注册，probe 会返回 -EPROBE_DEFER 并稍后重试
```

```
⚠️ 重要: 这是真正的上电操作，不是在 probe 阶段
- probe 阶段: 只获取资源，注册到链表
- rescan 阶段: 才真正操作硬件 (使能时钟、拉高GPIO)
```

## 技术要点总结

### Probe vs 上电

| 操作 | probe 阶段 | rescan 阶段 |
|------|-----------|------------|
| 获取 GPIO | ✅ devm_gpiod_get() | - |
| 获取时钟 | ✅ devm_clk_get() | - |
| 使能时钟 | ❌ | ✅ clk_prepare_enable() |
| 操作 GPIO | ❌ | ✅ gpiod_set_value() |
| 注册到链表 | ✅ | - |

### 依赖保证机制

```
mmc_pwrseq_alloc() {
    // 遍历全局链表
    list_for_each_entry(p, &pwrseq_list, pwrseq_node) {
        if (匹配) {
            return 0;  // 找到
        }
    }
    return -EPROBE_DEFER;  // 未找到，延迟 probe
}
```

**关键点**：
- 如果依赖未满足，probe 返回 `-EPROBE_DEFER`
- 内核会将设备加入延迟队列
- 当有新驱动注册时，重试延迟队列中的设备
- 保证了 `mmc_rescan` 执行时，pwrseq 一定已注册

## 修改文件

- `ap6255_driver_flow.md` - 主文档，多处更新

## 相关问题

### Q1: probe 阶段会执行上电吗？

**A**: 不会。probe 只获取资源并注册到链表，不操作硬件。

### Q2: 什么时候真正上电？

**A**: 在 `mmc_rescan()` 工作队列中调用 `mmc_pwrseq_pre_power_on()` 时。

### Q3: mmc_rescan 执行时，pwrseq 可能未注册吗？

**A**: 不可能。如果 pwrseq 未注册，`mmc_pwrseq_alloc()` 返回 `-EPROBE_DEFER`，导致 sdio0 的 probe 失败并稍后重试。只有 pwrseq 已注册，才会执行到 `mmc_start_host()` 触发 `mmc_rescan()`。

### Q4: 为什么要分两个阶段？

**A**:
1. **解耦**: probe 只负责资源获取，不关心使用时机
2. **灵活**: 上电时机由 MMC 核心控制，可以多次上下电
3. **安全**: 避免在 probe 阶段意外操作硬件

## 验证方法

### 添加调试打印

```c
// drivers/mmc/core/pwrseq_simple.c
static int mmc_pwrseq_simple_probe(struct platform_device *pdev)
{
    pr_info("[PWRSEQ] probe: 获取资源，不上电\n");
    // ...
    return mmc_pwrseq_register(&pwrseq->pwrseq);
}

static void mmc_pwrseq_simple_pre_power_on(struct mmc_host *host)
{
    pr_info("[PWRSEQ] pre_power_on: 真正上电\n");
    clk_prepare_enable(pwrseq->ext_clk);
    gpiod_set_value_cansleep(pwrseq->reset_gpio, 1);
}
```

### 查看 dmesg

```bash
dmesg | grep PWRSEQ
# 输出:
# [    1.234] [PWRSEQ] probe: 获取资源，不上电
# [    2.345] [PWRSEQ] pre_power_on: 真正上电
```

可以看到 probe 和上电是两个独立的时间点。

---

**更新时间**: 2026-02-28 12:00
**更新人**: Claude Sonnet 4.6
**文档版本**: 1.1
